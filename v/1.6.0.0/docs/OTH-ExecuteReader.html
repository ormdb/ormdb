To retrieve data, create an instance of a SQL.IQueryable object, and then records can be read by calling <k>ExecuteReader</k>.
The <k>ExecuteReader</k> provides an <b>unbuffered</b> stream of data that allows procedural logic to efficiently process results from a data source sequentially.

<co type="success">
	The ExecuteReader is a good choice when you're retrieving large amounts of data because the data is not cached in memory.
</co>

<st>Definition</st>
<co type="light">
	<small>
		<b>Namespace : </b>Odb
	</small>
</co>


<code-tab>
	<pre lang="c#">
		public IEnumerable&lt;T&gt; ExecuteReader&lt;T&gt;(this Odb.SQL.IQueryable o, Odb.Connection Connection)

		public IEnumerable&lt;IDataRecord&gt; ExecuteReader(this Odb.SQL.IQueryable o, Odb.Connection Connection)

		public IEnumerable&lt;IDataRecord&gt; ExecuteReader(this Data.Common.DbCommand o, Odb.Connection Connection)
	</pre>
	<pre lang="vb">
		Public Function ExecuteReader(Of T)(o As Odb.SQL.IQueryable, Connection As Odb.Connection) As IEnumerable(Of T)

		Public Function ExecuteReader(o As Odb.SQL.IQueryable, Connection As Odb.Connection) As IEnumerable(Of IDataRecord)

		Public Function ExecuteReader(Cmd As Data.Common.DbCommand, Connection As Odb.Connection) As IEnumerable(Of IDataRecord)
	</pre>
</code-tab>
<co type="warning">
	These methods are come as an extension methods. So you have to <k>Imports/using</k> <b>Odb</b>  to use them.
</co>
<br />


<st>Examples</st>
<ew></ew>

<br />
<br />
<include src="$/EXM/ExecuteReaderByStronglyTyped.html"></include>
<br />
<br />
<include src="$/EXM/ExecuteReaderByTableField.html"></include>