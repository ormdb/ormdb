To retrieve data, create an instance of a SQL.IQueryable object, and then records can be read by calling <k>ExecuteReader</k>.
The <k>ExecuteReader</k> provides an <b>unbuffered</b> stream of data that allows procedural logic to efficiently process results from a data source sequentially.

<co type="success">
	The ExecuteReader is a good choice when you're retrieving large amounts of data because the data is not cached in memory.
</co>


<st>Definition</st>
<co type="light">
	<small>
		<b>Namespace : </b>Odb
		<co type="warning">
			These methods are come as an extension methods. So you have to <b>include</b> or <b>import</b> to use them.
		</co>
	</small>
</co>
<code-tab>
	<pre lang="c#">
		public IEnumerable&lt;Odb.DataRow&gt; ExecuteReader(this Odb.SQL.IQueryable o, Odb.Connection Connection)

		public IEnumerable&lt;Odb.DataRow&gt; ExecuteReader(this Data.Common.DbCommand o, Odb.Connection Connection)
	</pre>
	<pre lang="vb">
		Public Function ExecuteReader(o As Odb.SQL.IQueryable, Connection As Odb.Connection) As IEnumerable(Of Odb.DataRow)

		Public Function ExecuteReader(Cmd As Data.Common.DbCommand, Connection As Odb.Connection) As IEnumerable(Of Odb.DataRow)
	</pre>
</code-tab>
<co type="light">
	<small><b>Namespace : </b>Odb.Connection</small>
</co>
<code-tab>
	<pre lang="c#">
		public IEnumerable&lt;Odb.DataRow&gt; ExecuteNonQuery(TSQL As String)

		public IEnumerable&lt;Odb.DataRow&gt; ExecuteNonQuery(Cmd As Data.Common.DbCommand)
	</pre>
	<pre lang="vb">
		Public Function ExecuteNonQuery(TSQL As String) As IEnumerable(Of Odb.DataRow)

		Public Function ExecuteNonQuery(Cmd As Data.Common.DbCommand) As IEnumerable(Of Odb.DataRow)
	</pre>
</code-tab>


<st>Examples</st>
<ew></ew>

<br />
<br />
<include src="$/EXM/ExecuteReaderByIteration.html"></include>