To retrieve data using a <k>DataTableReader</k>, create an instance of a SQL.IQueryable object, and then create a reader by calling <k>ExecuteReader</k>. 
The <k>DataTableReader</k> provides an <b>unbuffered</b> stream of data that allows procedural logic to efficiently process results from a data source sequentially. 

<co type="success">
	The DataTableReader is a good choice when you're retrieving large amounts of data because the data is not cached in memory.
</co>


<table>
	<thead>
		<th>Operation</th>
		<th>DataTable</th>
		<th>DataTableReader</th>
	</thead>
	<tr><td>Schema Information                        </td><td>Yes					</td><td>Yes							</td></tr>
	<tr><td>CRUD operations can be operate as offline.</td><td>Yes					</td><td>No								</td></tr>
	<tr><td>Moving the cursor on the records.         </td><td>Yes					</td><td>No								</td></tr>
	<tr><td>Getting RecordCount                       </td><td>Yes					</td><td>is the number of rows iterated	</td></tr>
	<tr><td>ToDataTable support                       </td><td>Yes					</td><td>Yes							</td></tr>
	<tr><td>Cursor Mode                               </td><td>READ_ONLY or UPDATE	</td><td>FORWARD_ONLY					</td></tr>
</table>


<st>Examples</st>
<ew/>
<br/>
<br/>
Following example iterates through a DataReader object and returns two columns from each row.

<code-tab>
	<code lang="c#">
		var sql = SQL.X.Select(h.Note, h.DocDate).From(h);
		var dr = sql.ExecuteReader(cn);
	</code>
	<code lang="vb">
		Dim sql = SQL.X.Select(h.Note, h.DocDate).From(h)
		Dim dr = sql.ExecuteReader(cn)
	</code>
</code-tab>

<br/>

<code-tab>
	<code lang="c#">
		foreach (var r in dr) {

			// read by column-name.
			Console.WriteLine("{0}, {1}", r("Note").ToString(), 
										  r("DocDate").ToString());

			// read by column. (REGULAR)
			Console.WriteLine("{0}, {1}", r(h.Note).ToString(), 
										  r(h.DocDate).ToString());

			// read by column-index. (more faster)
			Console.WriteLine("{0}, {1}", r(0).ToString(), 
										  r(1).ToString());
		}

		// read by binded-column. (more faster)
		var f1 = dr(h.Note);
		var f2 = dr(h.DocDate);
		foreach (var r in dr) {
			Console.WriteLine("{0}, {1}", f1.ToString(), f2.ToString());
		}
	</code>
	<code lang="vb">
		For Each r In dr

			' read by column-name.
			Console.WriteLine("{0}, {1}", r("Note").ToString(), 
										  r("DocDate").ToString())

			' read by column. (REGULAR)
			Console.WriteLine("{0}, {1}", r(h.Note).ToString(), 
										  r(h.DocDate).ToString())

			' read by column-index. (more faster)
			Console.WriteLine("{0}, {1}", r(0).ToString(), 
										  r(1).ToString())
		Next

		' read by binded-column. (more faster)
		Dim f1 = dr(h.Note)
		Dim f2 = dr(h.DocDate)
		For Each r In dr
			Console.WriteLine("{0}, {1}", f1.ToString(),  f2.ToString())
		Next
	</code>
	</code>
</code-tab>

<br/>

<table>
	<thead>
		<th>Reading By</th>
		<th>Performance</th>
		<th>Memory Consumption</th>
	</thead>
	<tr><td>column-name		</td><td>0.0000057 ms		</td><td>new instance for per column</td></tr>
	<tr><td>column-info		</td><td>0.0000035 ms		</td><td>new instance for per column (REGULAR)</td></tr>
	<tr><td>index info		</td><td>0.0000028 ms		</td><td>new instance for per column</td></tr>
	<tr><td>binded			</td><td>0.0000025 ms		</td><td>one instance for all columns</td></tr>
</table>

<co type="light">
	Record Count= 1200, Network= CAT6 gigabit, Server= MsSQL 2016
</co>